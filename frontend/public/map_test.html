<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AidSight Heat Map</title>
    <style>
        body { margin: 0; padding: 0; background: #0a0e1a; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #0a0e1a; }
        .leaflet-container,
        .leaflet-map-pane,
        .leaflet-tile-pane,
        .leaflet-tile-pane .leaflet-tile {
            background: #1e3a5f !important;
        }
        .leaflet-tile-pane {
            filter: brightness(0.55) saturate(1.2) contrast(1.05);
        }
        
        .mapboxgl-popup-content { background: rgba(0, 0, 0, 0.8); color: white; font-family: Arial, sans-serif; border-radius: 4px; padding: 10px; }
        
        /* 1. Epicenter Radial Pulse */
        .radial-ring {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background-color: rgba(239, 68, 68, 0.3);
            border: 2px solid rgba(239, 68, 68, 0.8);
            animation: ripple 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) infinite;
            margin: -40px 0 0 -40px; /* Centers the ring perfectly */
        }
        @keyframes ripple {
            0% { transform: scale(0.1); opacity: 1; }
            100% { transform: scale(3.5); opacity: 0; }
        }

        /* 2. Shooting Beam (Draws out, then fades) */
        .shooting-beam {
            stroke-dasharray: 1000; /* Create a massive dashed line */
            stroke-dashoffset: 1000; /* Push the dash completely off screen */
            animation: shoot-and-fade 1.5s ease-in-out forwards;
            filter: drop-shadow(0 0 6px rgba(239, 68, 68, 1));
        }
        @keyframes shoot-and-fade {
            0% { stroke-dashoffset: 1000; opacity: 1; }
            60% { stroke-dashoffset: 0; opacity: 1; } /* Beam hits neighbor */
            100% { stroke-dashoffset: 0; opacity: 0; } /* Beam fades out completely */
        }

        /* 3. Data Tooltip (Waits for sequence to finish) */
        .impact-label {
            background: rgba(15, 20, 33, 0.95);
            border: 1px solid #ef4444;
            color: #f3f4f6;
            font-family: monospace;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            opacity: 0;
            animation: fade-in 0.5s ease-in forwards;
            animation-delay: 1.9s; /* Appears right when the pulse stops */
        }
        @keyframes fade-in { to { opacity: 1; } }

        /* 4. Dark Mode Leaflet Popups - whole popup dark */
        .leaflet-popup,
        .leaflet-popup-content-wrapper,
        .leaflet-popup-content,
        .leaflet-popup-tip {
            background: #0f1421 !important;
            color: #e5e7eb;
        }
        .leaflet-popup-content-wrapper {
            border: 1px solid #374151;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        .leaflet-popup-content {
            margin: 12px 16px;
            font-family: ui-sans-serif, system-ui, sans-serif;
            font-size: 13px;
        }
        .leaflet-popup-close-button {
            color: #9ca3af !important;
        }
        .popup-card {
            min-width: 180px;
        }
        .popup-title {
            font-weight: bold;
            font-size: 15px;
            color: #f3f4f6;
            margin-bottom: 8px;
            border-bottom: 1px solid #374151;
            padding-bottom: 6px;
        }
        .popup-line {
            font-size: 13px;
            color: #d1d5db;
            margin-bottom: 4px;
        }
        .popup-metric {
            font-family: ui-monospace, monospace;
            color: #fca5a5;
        }
        .popup-tag {
            margin-top: 8px;
            font-size: 11px;
            color: #fbbf24;
            background: rgba(251, 191, 36, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }
        /* Hover tooltip: country name only, no frame */
        .leaflet-tooltip.country-tooltip {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            color: #e5e7eb;
            font-size: 13px;
            font-weight: 500;
            padding: 2px 4px;
        }
        /* No focus/click border on country shapes */
        .leaflet-interactive:focus,
        .leaflet-interactive:focus-visible {
            outline: none !important;
        }
    </style>
</head>
<body>

    <div id="map"></div>

    <script>
        (function () {
            function loadCSS(href) {
                return new Promise((res, rej) => {
                    if (document.querySelector(`link[href="${href}"]`)) return res();
                    const l = document.createElement('link'); l.rel = 'stylesheet'; l.href = href;
                    l.onload = res; l.onerror = rej; document.head.appendChild(l);
                });
            }
            function loadScript(src) {
                return new Promise((res, rej) => {
                    if (document.querySelector(`script[src="${src}"]`)) return res();
                    const s = document.createElement('script'); s.src = src;
                    s.onload = res; s.onerror = rej; document.head.appendChild(s);
                });
            }

            Promise.all([
                loadCSS('https://unpkg.com/leaflet@1.9.4/dist/leaflet.css'),
                loadScript('https://unpkg.com/leaflet@1.9.4/dist/leaflet.js')
            ]).then(init).catch(err => console.error('Failed to load dependencies', err));

            function init() {
                const map = L.map('map', { 
                    zoomControl: true, minZoom: 2, 
                    maxBounds: [[-90, -180], [90, 180]],
                    attributionControl: false
                }).setView([20, 0], 2); 

                // GeoJSON loading order: AFTERSHOCK_AFFECTED can arrive before geojsonLayer exists.
                // Queue messages until ready, then drain. Avoids silent failure when message arrives early.
                var geojsonLayerRef = { current: null };
                var geojsonReady = false;
                var pendingAftershockMessages = [];
                var lastAftershockData = { epicenter: '', affected: [] };

                var darkBaselineStyle = { fillColor: '#1e293b', weight: 0.8, opacity: 1, color: '#334155', fillOpacity: 0.7 };

                // Spectrum: criticality 0 (best) -> green; 1 (worst) -> red. Continuous shades; same scale for epicenter and neighbors.
                function hex2rgb(h) {
                    var m = h.replace(/^#/, '').match(/.{2}/g);
                    return m ? m.map(function(x) { return parseInt(x, 16); }) : [0,0,0];
                }
                function rgb2hex(r, g, b) {
                    return '#' + [r,g,b].map(function(x) { return ('0' + Math.round(x).toString(16)).slice(-2); }).join('');
                }
                function lerpColor(hexA, hexB, t) {
                    var a = hex2rgb(hexA), b = hex2rgb(hexB);
                    return rgb2hex(a[0] + (b[0]-a[0])*t, a[1] + (b[1]-a[1])*t, a[2] + (b[2]-a[2])*t);
                }
                var spectrumStops = [
                    { t: 0,   fill: '#14532d', border: '#166534' },
                    { t: 0.33, fill: '#4d7c0f', border: '#65a30d' },
                    { t: 0.55, fill: '#a16207', border: '#ca8a04' },
                    { t: 0.78, fill: '#c2410c', border: '#ea580c' },
                    { t: 1,   fill: '#7f1d1d', border: '#dc2626' }
                ];
                function criticalityToColor(c) {
                    var t = Math.max(0, Math.min(1, c));
                    var i = 0;
                    while (i + 1 < spectrumStops.length && spectrumStops[i + 1].t <= t) i++;
                    var low = spectrumStops[i], high = spectrumStops[i + 1] || low;
                    var u = (high.t === low.t) ? 1 : (t - low.t) / (high.t - low.t);
                    return {
                        fill: lerpColor(low.fill, high.fill, u),
                        border: lerpColor(low.border, high.border, u)
                    };
                }

                function applyAftershockStyling(layer, data) {
                    if (!layer) return;
                    var affected = data.affected || [];
                    var neighbors = data.neighbors || [];
                    var epicenterIso = (data.epicenter || '').toUpperCase();
                    var epicenterCriticality = typeof data.epicenter_criticality === 'number' ? data.epicenter_criticality : 0.7;
                    var criticalityByIso = {};
                    if (epicenterIso) criticalityByIso[epicenterIso] = epicenterCriticality;
                    neighbors.forEach(function(n) {
                        var iso = (typeof n === 'string' ? n : (n && n.country)) ? (typeof n === 'string' ? n : n.country).toUpperCase() : '';
                        var crit = (typeof n === 'object' && n && typeof n.criticality === 'number') ? n.criticality : 0.5;
                        if (iso) criticalityByIso[iso] = crit;
                    });
                    var postCriticalityByIso = {};
                    var deltaDisplacedByIso = {};
                    affected.forEach(function(a) {
                        var iso = (a.country || '').toUpperCase();
                        if (typeof a.post_criticality === 'number') postCriticalityByIso[iso] = a.post_criticality;
                        if (iso) deltaDisplacedByIso[iso] = a.delta_displaced ?? a.impact ?? 0;
                    });
                    Object.keys(postCriticalityByIso).forEach(function(iso) { criticalityByIso[iso] = postCriticalityByIso[iso]; });
                    // 1. Reset ALL layers to dark baseline
                    layer.eachLayer(function(l) {
                        l.setStyle(darkBaselineStyle);
                    });
                    if (!epicenterIso && affected.length === 0 && neighbors.length === 0) return;
                    var impacts = affected.map(function(a) { return Math.abs(a.delta_displaced ?? a.impact ?? 0); });
                    var maxImpact = Math.max(1, Math.max.apply(null, impacts));
                    function impactWeight(absImpact) {
                        var r = maxImpact > 0 ? absImpact / maxImpact : 0;
                        if (r <= 0.33) return 2;
                        if (r <= 0.66) return 3;
                        return 4;
                    }
                    layer.eachLayer(function(l) {
                        var p = l.feature.properties || {};
                        var iso = (p['ISO3166-1-Alpha-3'] || p.ISO_A3 || p.ADM0_A3 || p.iso_a3 || '').toString().toUpperCase();
                        var hit = affected.find(function(a) { return (a.country || '').toUpperCase() === iso; });
                        var isEpicenter = iso && epicenterIso && (iso.indexOf(epicenterIso) !== -1 || epicenterIso.indexOf(iso) !== -1);
                        var criticality = criticalityByIso[iso];
                        var hasCriticality = typeof criticality === 'number';
                        var colors = hasCriticality ? criticalityToColor(criticality) : null;
                        var isAffected = !!hit;
                        var deltaD = deltaDisplacedByIso[iso];
                        var hasPost = typeof postCriticalityByIso[iso] === 'number';
                        if (isAffected && hasCriticality) {
                            var absImpact = Math.abs(deltaD);
                            var borderColor = isEpicenter ? '#e5e7eb' : (deltaD > 0 ? '#ef4444' : deltaD < 0 ? '#22c55e' : '#94a3b8');
                            l.setStyle({
                                weight: isEpicenter ? 5 : (hasPost ? impactWeight(absImpact) : 3),
                                color: borderColor,
                                fillColor: colors.fill,
                                fillOpacity: hasPost ? 0.75 : 0.6
                            });
                            l.bringToFront();
                        } else if (isEpicenter && epicenterIso && colors) {
                            l.setStyle({
                                weight: 5,
                                color: '#e5e7eb',
                                fillColor: colors.fill,
                                fillOpacity: 0.75
                            });
                            l.bringToFront();
                        } else if (hasCriticality && colors) {
                            l.setStyle({
                                weight: 1.2,
                                color: colors.border,
                                fillColor: colors.fill,
                                fillOpacity: 0.6
                            });
                        }
                    });
                }

                // --- ADD DARK MODE LEGEND ---
                const legend = L.control({ position: 'bottomright' });
                legend.onAdd = function () {
                    const div = L.DomUtil.create('div', 'info legend');
                    div.style.background = '#0f1421';
                    div.style.color = '#e5e7eb';
                    div.style.padding = '12px 16px';
                    div.style.borderRadius = '8px';
                    div.style.border = '1px solid #1f2937';
                    div.style.fontFamily = 'monospace';
                    div.style.fontSize = '12px';
                    div.style.boxShadow = '0 4px 6px rgba(0,0,0,0.5)';
                    
                    div.innerHTML = `
                        <div style="font-weight:bold; margin-bottom:10px; color:#fff; text-transform:uppercase; font-size:10px; letter-spacing:0.05em;">Map Legend</div>
                        <div style="margin-bottom:6px; font-size:11px;">Criticality (fill)</div>
                        <div style="display:flex; align-items:center; gap:2px; margin-bottom:8px;">
                            <span style="width:10px; height:12px; background:#14532d; border-radius:1px;"></span>
                            <span style="width:10px; height:12px; background:#4d7c0f; border-radius:1px;"></span>
                            <span style="width:10px; height:12px; background:#a16207; border-radius:1px;"></span>
                            <span style="width:10px; height:12px; background:#c2410c; border-radius:1px;"></span>
                            <span style="width:10px; height:12px; background:#7f1d1d; border-radius:1px;"></span>
                            <span style="margin-left:4px; font-size:10px; color:#9ca3af;">low â†’ high</span>
                        </div>
                        <div style="font-size:10px; color:#9ca3af; margin-bottom:6px;">Pre = baseline; after Run = post-aftershock</div>
                        <div style="display:flex; align-items:center; margin-bottom:6px;">
                            <span style="width:14px; height:14px; border:2px solid #e5e7eb; border-radius:2px; margin-right:8px; background:transparent;"></span>
                            Epicenter
                        </div>
                        <div style="display:flex; align-items:center; margin-bottom:6px;">
                            <span style="width:14px; height:14px; border:2px solid #ef4444; border-radius:2px; margin-right:8px; background:transparent;"></span>
                            Worse (e.g. cut funding)
                        </div>
                        <div style="display:flex; align-items:center;">
                            <span style="width:14px; height:14px; border:2px solid #22c55e; border-radius:2px; margin-right:8px; background:transparent;"></span>
                            Better (e.g. more funding)
                        </div>
                    `;
                    return div;
                };
                legend.addTo(map);

                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap', maxZoom: 19
                }).addTo(map);

                const sahelISOs = ['MLI', 'BFA', 'NER', 'TCD'];
                const africaISOs = ['DZA','AGO','BEN','BWA','BFA','BDI','CPV','CMR','CAF','TCD','COM','COD','COG','DJI','EGY','GNQ','ERI','SWZ','ETH','GAB','GMB','GHA','GIN','GNB','CIV','KEN','LSO','LBR','LBY','MDG','MWI','MLI','MRT','MUS','MAR','MOZ','NAM','NER','NGA','RWA','STP','SEN','SYC','SLE','SOM','ZAF','SSD','SDN','TZA','TGO','TUN','UGA','ZMB','ZWE'];
                
                const sahelCentroids = {
                    'MLI': [17.5707, -3.9962], 'BFA': [12.2383, -1.5616],
                    'NER': [17.6078, 8.0817], 'TCD': [15.4542, 18.7322]
                };

                function getCentroidForIso(layer, iso) {
                    var target = (iso || '').toUpperCase();
                    var found = null;
                    layer.eachLayer(function(l) {
                        if (found) return;
                        var p = l.feature.properties || {};
                        var lIso = (p['ISO3166-1-Alpha-3'] || p.ISO_A3 || p.ADM0_A3 || '').toString().toUpperCase();
                        if (lIso === target) found = l.getBounds().getCenter();
                    });
                    return found;
                }

                function runSpreadAnimation(gl, epicenterIso, affected) {
                    var epicenterCoords = sahelCentroids[epicenterIso] || getCentroidForIso(gl, epicenterIso);
                    if (!epicenterCoords) return;
                    activeAnimations.clearLayers();
                    var pulseIcon = L.divIcon({ className: '', html: '<div class="radial-ring"></div>', iconSize: [0, 0] });
                    var pulseMarker = L.marker(epicenterCoords, { icon: pulseIcon }).addTo(activeAnimations);
                    affected.forEach(function(a) {
                        var iso = (a.country || '').toUpperCase();
                        var targetCoords = sahelCentroids[iso] || getCentroidForIso(gl, iso);
                        if (targetCoords) {
                            L.polyline([epicenterCoords, targetCoords], {
                                color: '#ef4444', weight: 4, opacity: 1, className: 'shooting-beam'
                            }).addTo(activeAnimations);
                        }
                    });
                    setTimeout(function() {
                        var affectedIsos = affected.map(function(a) { return (a.country || '').toUpperCase(); });
                        gl.eachLayer(function(layer) {
                            var lp = layer.feature.properties || {};
                            var iso = (lp['ISO3166-1-Alpha-3'] || lp.ISO_A3 || lp.ADM0_A3 || lp.iso_a3 || '').toString().toUpperCase();
                            if (affectedIsos.indexOf(iso) !== -1) {
                                layer.setStyle({ fillColor: '#ef4444', fillOpacity: 0.9 });
                                setTimeout(function() { layer.setStyle({ fillColor: '#006837', fillOpacity: 0.7 }); }, 250);
                                setTimeout(function() { layer.setStyle({ fillColor: '#ef4444', fillOpacity: 0.9 }); }, 500);
                                setTimeout(function() { layer.setStyle({ fillColor: '#006837', fillOpacity: 0.7 }); }, 750);
                                setTimeout(function() { layer.setStyle({ fillColor: '#7f1d1d', fillOpacity: 0.85 }); }, 1000);
                            }
                        });
                    }, 900);
                    setTimeout(function() { activeAnimations.removeLayer(pulseMarker); }, 1900);
                }

                const activeAnimations = L.layerGroup().addTo(map);

                // Message listener registered early so AFTERSHOCK_AFFECTED can be queued if GeoJSON not ready
                window.addEventListener('message', function eventHandler(event) {
                    var gl = geojsonLayerRef.current;

                    if (event.data.type === 'AFTERSHOCK_AFFECTED') {
                        console.log('[AidSight Map] Received AFTERSHOCK_AFFECTED:', { epicenter: event.data.epicenter, affected: event.data.affected });
                        if (!geojsonReady || !gl) {
                            pendingAftershockMessages.push(event.data);
                            return;
                        }
                        applyAftershockStyling(gl, event.data);
                        var data = event.data;
                        lastAftershockData = { epicenter: (data.epicenter || '').toUpperCase(), affected: data.affected || [] };
                        var epicenterIso = (data.epicenter || '').toUpperCase();
                        var affected = data.affected || [];
                        // Only zoom on dropdown selection (no affected yet), not when aftershock result arrives
                        if (affected.length === 0) {
                            var coords = sahelCentroids[epicenterIso] || getCentroidForIso(gl, epicenterIso);
                            if (coords) map.flyTo(coords, 5, { duration: 1.0 });
                        }
                        // When we have affected data, run spread animation (includes Nigeria and all actual affected)
                        if (affected.length > 0) runSpreadAnimation(gl, epicenterIso, affected);
                        return;
                    }

                    if (event.data.type === 'FOCUS_COUNTRY') {
                        if (!gl) return;
                        var iso = event.data.iso;
                        var coords = sahelCentroids[iso];
                        if (coords) {
                            map.flyTo(coords, 5, { duration: 1.0 });
                        }
                        return;
                    }

                });

                fetch('https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson?v=2')
                .then(r => r.json())
                .then(geojson => {
                    const geojsonLayer = L.geoJson(geojson, {
                        style: function() {
                            return { fillColor: '#1e293b', weight: 0.8, opacity: 1, color: '#334155', fillOpacity: 0.7 };
                        },
                        onEachFeature: (feature, layer) => {
                            let p = feature.properties;
                            let iso = (p['ISO3166-1-Alpha-3'] || p.ISO_A3 || p.ADM0_A3 || p.ADMIN || '').toString().toUpperCase();
                            let countryName = p.name || p.NAME || p.ADMIN || 'Unknown Region';

                            layer.bindTooltip(countryName, {
                                permanent: false,
                                direction: 'top',
                                className: 'country-tooltip',
                                opacity: 1
                            });

                            layer.bindPopup(function() {
                                var d = lastAftershockData;
                                var lines = [];
                                if (d.epicenter && iso === d.epicenter) {
                                    lines.push('<div class="popup-title">' + countryName + ', 2024 Sahel crisis</div>');
                                    lines.push('<div class="popup-line">Epicenter of current scenario</div>');
                                } else {
                                    var hit = d.affected && d.affected.find(function(a) { return (a.country || '').toUpperCase() === iso; });
                                    if (hit) {
                                        var n = Math.abs(hit.delta_displaced ?? hit.impact ?? 0);
                                        var disp = n >= 1e6 ? (n/1e6).toFixed(1) + 'M' : n >= 1e3 ? (n/1e3).toFixed(1) + 'K' : n.toLocaleString();
                                        var cost = hit.extra_cost_usd;
                                        var costStr = cost >= 1e6 ? '$' + (cost/1e6).toFixed(1) + 'M' : cost >= 1e3 ? '$' + (cost/1e3).toFixed(1) + 'K' : '$' + cost.toLocaleString();
                                        lines.push('<div class="popup-title">' + countryName + ', 2024 Sahel crisis</div>');
                                        lines.push('<div class="popup-line popup-metric">+' + disp + ' displaced</div>');
                                        lines.push('<div class="popup-line popup-metric">+' + costStr + ' USD response cost</div>');
                                        var prob = hit.prob_underfunded_next;
                                        if (typeof prob === 'number' && prob > 0.5) {
                                            lines.push('<div class="popup-tag">High aftershock risk</div>');
                                        }
                                    }
                                }
                                if (lines.length === 0) {
                                    lines.push('<div class="popup-title">' + countryName + '</div>');
                                    lines.push('<div class="popup-line">Run Aftershock to see impact.</div>');
                                }
                                return '<div class="popup-card">' + lines.join('') + '</div>';
                            });

                            // Zoom to clicked country only; do not re-style layers (preserves aftershock state)
                            layer.on('click', () => {
                                var bounds = layer.getBounds();
                                if (bounds.isValid()) {
                                    map.flyToBounds(bounds, { padding: [40, 40], duration: 0.8, maxZoom: 7 });
                                }
                            });
                        }
                    }).addTo(map);

                    geojsonLayerRef.current = geojsonLayer;
                    geojsonReady = true;
                    while (pendingAftershockMessages.length > 0) {
                        var msg = pendingAftershockMessages.shift();
                        lastAftershockData = { epicenter: (msg.epicenter || '').toUpperCase(), affected: msg.affected || [] };
                        applyAftershockStyling(geojsonLayer, msg);
                        var epicenterIso = (msg.epicenter || '').toUpperCase();
                        var affected = msg.affected || [];
                        if (affected.length === 0) {
                            var coords = sahelCentroids[epicenterIso] || getCentroidForIso(geojsonLayer, epicenterIso);
                            if (coords) map.flyTo(coords, 5, { duration: 1.0 });
                        }
                        if (affected.length > 0) runSpreadAnimation(geojsonLayer, epicenterIso, affected);
                    }
                }).catch(err => console.error(err));
            }
        })();
    </script>
</body>
</html>